import numpy as np
import math


def e2p(u_real):
    return np.vstack((u_real, np.ones((1, u_real.shape[1]))))


def p2e(u_homogeneous):
    u_homogeneous /= u_homogeneous[-1:, :]
    return u_homogeneous[:-1, :]


def vlen(x):
    return np.linalg.norm(x, axis=0)


def sqc(x):
    return np.array([[0, -x[2], x[1]],
                     [x[2], 0, -x[0]],
                     [-x[1], x[0], 0]])


def rodrigues(theta, axis):
    sqc_axis = sqc(axis)
    return np.eye(3) + sqc_axis * math.sin(theta) + sqc_axis @ sqc_axis * (1 - math.cos(theta))

"""
def EutoRt(E, u1p, u2p):
    u1p /= u1p[-1, :]
    u2p /= u2p[-1, :]
    U, D, VT = np.linalg.svd(E)

    if np.linalg.det(U) < 0:
        U = -U
    if np.linalg.det(VT.T) < 0:
        VT = -VT

    W1 = np.array([[0, 1, 0], [-1, 0, 0], [0, 0, 1]])
    W2 = W1.T

    R1 = U @ W1 @ VT
    R2 = U @ W2 @ VT

    t1 = -U[:, -1:]
    t2 = U[:, -1:]

    P1 = np.hstack((R1, t1))
    P2 = np.hstack((R1, t2))
    P3 = np.hstack((R2, t1))
    P4 = np.hstack((R2, t2))

    P_I = np.eye(3,4)
    Ps = [P1, P2, P3, P4]

    Ps_in_front_camera = []

    for P in Ps:
        is_behind = False
        for i in range(u1p.shape[1]):
            D = np.array([P_I[2, :] * u1p[0, i] - P_I[0, :],
                          P_I[2, :] * u1p[1, i] - P_I[1, :],
                          P2[2, :] * u2p[0, i] - P2[0, :],
                          P2[2, :] * u2p[1, i] - P2[1, :]])

            S = np.diag(1 / np.max(np.fabs(D), axis=0))
            D_conditioned = D @ S
            U, _, VT = np.linalg.svd(D_conditioned)
            X = VT[-1, :]
            X = S @ X
            X /= X[-1]
            X_P1 = P_I @ X
            X_P2 = P @ X

            if X_P1[2] < 0 or X_P2[2] < 0:
                is_behind = True
                break
        if not is_behind:
            Ps_in_front_camera.append(P)
    if len(Ps_in_front_camera) == 0:
        R = np.eye(3)
        t = np.zeros((3, 1))
    else:
        R = Ps_in_front_camera[0][:, :3]
        t = Ps_in_front_camera[0][:, -1:]
    return R, t
    # """


# """
def EutoRt(E, u1p, u2p):
    u1p /= u1p[-1, :]
    u2p /= u2p[-1, :]

    [U, D, V_T] = np.linalg.svd(E)

    if np.linalg.det(U) < 0:
        U = -U
    if np.linalg.det(V_T.T) < 0:
        V_T = -V_T

    W1 = np.array([[0, 1, 0], [-1, 0, 0], [0, 0, 1]])
    W2 = np.array([[0, -1, 0], [1, 0, 0], [0, 0, 1]])

    R1 = U @ W1 @ V_T
    R2 = U @ W2 @ V_T
    # if np.linalg.det(R1) < 0:
    #     R1 *= -1
    # if np.linalg.det(R2) < 0:
    #     R2 *= -1

    t1 = -U[:, -1:]
    t2 = U[:, -1:]

    P1 = np.concatenate((R1, t1), axis=1)
    P2 = np.concatenate((R1, t2), axis=1)
    P3 = np.concatenate((R2, t1), axis=1)
    P4 = np.concatenate((R2, t2), axis=1)

    P_I = np.hstack((np.eye(3), np.zeros((3, 1))))
    Ps = [P1, P2, P3, P4]

    Ps_in_front_camera = []

    for P in Ps:
        is_in_front = True
        for i in range(u1p.shape[1]):

            D = np.array([u1p[0, i] * P_I[2, :] - P_I[0, :],
                          u1p[1, i] * P_I[2, :] - P_I[1, :],
                          u2p[0, i] * P[2, :] - P[0, :],
                          u2p[1, i] * P[2, :] - P[1, :]])

            S = np.diag(1 / np.max(np.fabs(D), axis=0))
            D_conditioned = D @ S

            # U,_,_ = np.linalg.svd(D_conditioned.T @ D_conditioned)
            U, _, V_T = np.linalg.svd(D_conditioned)
            X = V_T[-1, :]
            # X = U[:,-1]
            X = S @ X
            X /= X[-1]

            # _,_,V_A_T = np.linalg.svd(D)
            # X = V_A_T[-1,:]

            X2 = P @ X

            if X[2] <= 0 or X2[2] <= 0:
                is_in_front = False
                break

        if is_in_front:
            Ps_in_front_camera.append(P)

    if len(Ps_in_front_camera) == 0:
        # return np.eye(3),t1
        return np.empty((3, 3)), np.empty((3, 1))
    elif len(Ps_in_front_camera) == 1:
        # print("ok")
        return Ps_in_front_camera[0][:, :3], Ps_in_front_camera[0][:, -1].reshape(-1, 1)
    else:
        # print(len(Ps_in_front_camera))
        print("tohle by nemelo nastat")
        # return np.eye(3),t1
        # print("ooooooof")
        return Ps_in_front_camera[0][:, :3], Ps_in_front_camera[0][:, -1].reshape(-1, 1)
# """

"""
def Pu2X(P1, P2, u1, u2):
    u1 = u1 / u1[2, :]
    u2 = u2 / u2[2, :]

    Xs = np.ones((4, u1.shape[1]))
    for i in range(u1.shape[1]):
        D = np.array(
            [P1[2, :] * u1[0, i] - P1[0, :],
             P1[2, :] * u1[1, i] - P1[1, :],
             P2[2, :] * u2[0, i] - P2[0, :],
             P2[2, :] * u2[1, i] - P2[1, :]]
        )
        S = np.diag(1.0 / np.max(np.abs(D), axis=0))
        D_stable = -D @ S
        U, _, VT = np.linalg.svd(D_stable)
        X = S @ VT[-1, :]
        Xs[:, i] = X
    return Xs
# """


def Pu2X(P1, P2, u1, u2):
    Xs = np.zeros((4, u1.shape[1]))
    u1 /= u1[-1, :]
    u2 /= u2[-1, :]

    for i in range(u1.shape[1]):
        D = np.array([u1[0, i] * P1[2, :] - P1[0, :],
                      u1[1, i] * P1[2, :] - P1[1, :],
                      u2[0, i] * P2[2, :] - P2[0, :],
                      u2[1, i] * P2[2, :] - P2[1, :]])

        S = np.diag(1 / np.max(np.fabs(D), axis=0))
        D_conditioned = D @ S

        U, _, _ = np.linalg.svd(D_conditioned.T @ D_conditioned)
        X = U[:, -1]
        X = S @ X

        """ print(vlen(D@X))
        print(vlen(X))
        print(vlen(D@X_ref[:,i]))
        print(vlen(X_ref[:,i]))

        print("------") """
        Xs[:, i] = X  # /X[-1]#np.vstack((X,1))

    return Xs


def err_F_sampson(Fp, u1p, u2p, square_num=True):
    u1p = u1p / u1p[-1, :]
    u2p = u2p / u2p[-1, :]
    # print(u1.shape)
    Fu1 = Fp @ u1p
    Fu2 = Fp.T @ u2p
    S = np.array([[1, 0, 0], [0, 1, 0]])
    SFu1 = S @ Fu1
    SFu2 = S @ Fu2
    Fu1dot = np.sum(SFu1 * SFu1, axis=0)
    Fu2dot = np.sum(SFu2 * SFu2, axis=0)

    denominator = Fu1dot + Fu2dot
    numerator = np.array([u2p[:, i] @ Fp @ u1p[:, i] for i in range(u1p.shape[1])])
    if square_num:
        es = numerator ** 2 / denominator
    else:
        es = numerator / denominator
    return es


def u_correct_sampson(F, u1, u2):
    err_sampson = err_F_sampson(F, u1, u2, square_num=False)
    u1 /= u1[-1, :]
    u2 /= u2[-1, :]
    stacked_us = np.vstack([u1[:2, :], u2[:2, :]])
    correction = err_sampson * np.vstack([F[:, :2].T @ u2, F[:2, :] @ u1])
    corrected_us = stacked_us - correction
    nu1 = np.ones(u1.shape)
    nu2 = np.ones(u2.shape)
    nu1[:2, :] = corrected_us[:2, :]
    nu2[:2, :] = corrected_us[2:, :]
    return nu1, nu2


def err_contributions(errs, theta=3):
    # print(1 - errs / theta**2)
    return np.clip(1 - errs / theta ** 2, 0, 1)


def Nmax(success_prob, inlier_ratio, number_of_params):
    # print(1-success_prob)
    # print(1 - inlier_ratio**number_of_params)
    # print(inlier_ratio)
    return math.log(0.99 - success_prob) / math.log(1.01 - inlier_ratio ** number_of_params)


def calc_F_R_t(R, t):
    F = R @ sqc(-R.T @ t)
    return F


# def calc_F(P2):
#     Q2 = P2[:, :3]
#     q2 = P2[:, -1]
#     invQ2 = np.linalg.inv(Q2)
#     F = invQ2.T @ sqc(-invQ2 @ q2)
#     return F
#
#
def calc_F(invK, t, R):
    F = invK.T @ sqc(-t) @ R @ invK
    return F


if __name__ == "__main__":
    # Input:
    E = [[0.23182618, -0.3312538, 0.42832968], [-0.00518477, 0.12417609, -0.85407926],
         [0.60956186, 0.67638332, 0.28125294]]
    u1 = [[0.24540581, 1.30694337, 1.34275256, 1.3083145, 1.65276237],
          [0.25342682, 1.99222454, 1.37654857, 1.34736433, 0.36929148],
          [5.63126795, 5.65195196, 5.9423791, 5.03494751, 5.08372868]]
    u2 = [[-0.76206362, 0.58579321, 0.38897182, 0.64922833, 0.73641581],
          [1.51058131, 3.01482059, 2.45056522, 2.29895939, 1.2919849],
          [5.62837247, 5.89530594, 6.22327597, 5.3660992, 5.60285048]]
    E = np.array(E)
    u1 = np.array(u1)
    u2 = np.array(u2)
    R, t = EutoRt(E, u1, u2)
    print(R)
    print(t)
    """
    Your output:
    R
    [[1. 0. 0.]
    [0. 1. 0.]
    [0. 0. 1.]]
    t
    [[0.]
    [0.]
    [0.]]
    Ref  output:
    R
    [[ 0.91891386  0.21807824 -0.32869317]
    [-0.17997315  0.97328056  0.14259952]
    [ 0.35100853 -0.07188073  0.93360922]]
    t
    [[0.80812204]
    [0.50507627]
    [0.30304576]]
    """

    # Input:
    F = [[-1.70737958e-09, -7.79412539e-08, 3.58179041e-04],
         [8.97812353e-08, -7.95377593e-08, -4.87817103e-04],
         [-2.90506236e-04, 6.65224301e-04, -2.12595400e-01]]
    u1 = [[650.37049885, 845.51831712, 935.78537752, 712.0067404, 892.27460367,
           864.13431127, 826.17731088, 687.03646697, 503.03192103, 727.9935841],
          [433.8598567, 760.6571106, 398.89445506, 648.07229504, 585.48137647,
           501.90853188, 634.13734203, 850.69653768, 486.49720556, 668.27052189],
          [1., 1., 1., 1., 1.,
           1., 1., 1., 1., 1.]]
    u2 = [[8.81790285e+02, 9.97574616e+02, 1.22563522e+03, 9.00723304e+02,
           1.10278622e+03, 1.04624578e+03, 9.70249439e+02, 8.57456767e+02,
           6.86755622e+02, 8.77182686e+02], [4.27239426e+02, 7.60183986e+02, 4.42979826e+02, 6.44099205e+02,
                                             5.83213151e+02, 4.72559456e+02, 5.97217193e+02, 8.50649632e+02,
                                             4.28154436e+02, 6.26967145e+02],
          [1.00000000e+00, 1.00000000e+00, 1.00000000e+00, 1.00000000e+00,
           1.00000000e+00, 1.00000000e+00, 1.00000000e+00, 1.00000000e+00, 1.00000000e+00, 1.00000000e+00]]
    # Your output:
    err = [-37241.89465878, -22835.95210946, -20287.70264575, -27628.74070134,
           -6636.57047712, -15363.64676769, -14711.55129617, -25991.58794498,
           -29856.11482428, -15305.90761214]
    # Ref  output:
    err = [971.55158627, 333.50754871, 265.55921817, 511.83951688, 28.39433092,
           156.76673484, 142.97476512, 443.50948766, 652.06442068, 157.87398135]
    F = np.array(F)
    u1 = np.array(u1)
    u2 = np.array(u2)
    err_f = err_F_sampson(F, u1, u2)
    # print(err_f)
    # Input:
    F = [[-1.70737958e-09, -7.79412539e-08, 3.58179041e-04], [8.97812353e-08, -7.95377593e-08, -4.87817103e-04],
         [-2.90506236e-04, 6.65224301e-04, -2.12595400e-01]]
    u1 = [
        [650.37049885, 845.51831712, 935.78537752, 712.0067404, 892.27460367, 864.13431127, 826.17731088, 687.03646697,
         503.03192103, 727.9935841, ],
        [433.8598567, 760.6571106, 398.89445506, 648.07229504, 585.48137647, 501.90853188, 634.13734203, 850.69653768,
         486.49720556, 668.27052189], [1., 1., 1., 1., 1., 1., 1., 1., 1., 1., ]]
    u2 = [
        [8.81790285e+02, 9.97574616e+02, 1.22563522e+03, 9.00723304e+02, 1.10278622e+03, 1.04624578e+03, 9.70249439e+02,
         8.57456767e+02, 6.86755622e+02, 8.77182686e+02],
        [4.27239426e+02, 7.60183986e+02, 4.42979826e+02, 6.44099205e+02, 5.83213151e+02, 4.72559456e+02, 5.97217193e+02,
         8.50649632e+02, 4.28154436e+02, 6.26967145e+02],
        [1.00000000e+00, 1.00000000e+00, 1.00000000e+00, 1.00000000e+00, 1.00000000e+00, 1.00000000e+00, 1.00000000e+00,
         1.00000000e+00, 1.00000000e+00, 1.00000000e+00]]
    F = np.array(F)
    u1 = np.array(u1)
    u2 = np.array(u2)
    nu1, nu2 = u_correct_sampson(F, u1, u2)
    # print(nu1)
    # print(nu2)
    # Your output:
    """
    nu1
    [[659.81704334 850.63263908 940.91466838 718.47783602 893.86756318
    867.97315813 829.68666203 692.64019785 510.59264038 731.60140134]
    [412.91074    748.62236394 388.05142595 633.04804584 581.9448523
    493.51856309 626.16220233 836.90191097 469.25102199 659.89837378]
    [  1.           1.           1.           1.           1.
        1.           1.           1.           1.           1.        ]]
    nu2
    [[8.69751730e+02 9.90782088e+02 1.21903176e+03 8.92256426e+02
    1.10072210e+03 1.04136653e+03 9.65727947e+02 8.49900970e+02
    6.77219520e+02 8.72516677e+02]
    [4.44517218e+02 7.70971835e+02 4.51815695e+02 6.57234972e+02
    5.86227983e+02 4.79475475e+02 6.04044526e+02 8.63484190e+02
    4.42525652e+02 6.34246783e+02]
    [1.00000000e+00 1.00000000e+00 1.00000000e+00 1.00000000e+00
    1.00000000e+00 1.00000000e+00 1.00000000e+00 1.00000000e+00
    1.00000000e+00 1.00000000e+00]]
    Ref  output:
    nu1
    [[640.92395435 840.40399517 930.65608667 705.53564478 890.68164416
    860.29546441 822.66795973 681.43273609 495.47120168 724.38576686]
    [454.8089734  772.69185727 409.73748416 663.09654424 589.01790064
    510.29850066 642.11248172 864.49116439 503.74338912 676.64267   ]
    [  1.           1.           1.           1.           1.
        1.           1.           1.           1.           1.        ]]
    nu2
    [[8.93828840e+02 1.00436714e+03 1.23223868e+03 9.09190181e+02
    1.10485034e+03 1.05112503e+03 9.74770931e+02 8.65012565e+02
    6.96291724e+02 8.81848696e+02]
    [4.09961635e+02 7.49396136e+02 4.34143958e+02 6.30963439e+02
    5.80198320e+02 4.65643438e+02 5.90389860e+02 8.37815073e+02
    4.13783220e+02 6.19687508e+02]
    [1.00000000e+00 1.00000000e+00 1.00000000e+00 1.00000000e+00
    1.00000000e+00 1.00000000e+00 1.00000000e+00 1.00000000e+00
    1.00000000e+00 1.00000000e+00]]
    """
    # Input:
    P1 = [[1.5e+03, 0.0e+00, 5.0e+02, 0.0e+00], [0.0e+00, 1.5e+03, 4.0e+02, 0.0e+00],
          [0.0e+00, 0.0e+00, 1.0e+00, 0.0e+00]]
    P2 = [[1.37385333e+03, -1.84169607e+02, 1.15265284e+03, 1.55563492e+03],
          [4.94883869e+02, 1.70051165e+03, -5.78797771e+01, 1.01015254e+03],
          [-2.50767418e-01, 3.97057625e-01, 8.82870854e-01, 3.03045763e-01]]
    u1 = [[661.26175152, 774.890817, 646.13474072, 940.34769148, 523.09276315, 757.33111242, 683.85094161, 673.48063334,
           752.56338656, 741.82299081],
          [487.44241813, 488.6113372, 859.17767475, 600.24569517, 773.34859246, 788.09719071, 764.50620836,
           798.11728361, 850.67116128, 418.50572368], [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]]
    u2 = [
        [1.50832157e+03, 1.57675851e+03, 1.40094632e+03, 1.86501282e+03, 1.19604833e+03, 1.70861756e+03, 1.48592483e+03,
         1.42696334e+03, 1.39325358e+03, 1.80291618e+03],
        [3.21666400e+02, 3.41136578e+02, 6.80166700e+02, 5.53620454e+02, 4.77840093e+02, 8.52797238e+02, 6.24053543e+02,
         6.29458146e+02, 6.61864763e+02, 3.55479592e+02],
        [1.00000000e+00, 1.00000000e+00, 1.00000000e+00, 1.00000000e+00, 1.00000000e+00, 1.00000000e+00, 1.00000000e+00,
         1.00000000e+00, 1.00000000e+00, 1.00000000e+00]]
    """
    Your output:
    X
    [[1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
    [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
    [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
    [1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
    Ref  output:
    X
    [[-0.16779554 -0.24260811  0.11438902  0.31266461  0.03828314  0.23237357
    0.15382492  0.14497966  0.20288406 -0.17212536]
    [-0.10330301 -0.09882953  0.31711279  0.1496563   0.27376814  0.31368219
    0.27192741  0.29262622  0.33082221 -0.0227139 ]
    [-0.97293752 -0.95869799  0.93449987  0.92638503  0.96033869  0.89602345
    0.94318692  0.9412683   0.92160915 -0.94630256]
    [-0.12068858 -0.11077995  0.11430061  0.14715506  0.03653779  0.21153718
    0.11310091  0.08581834 -0.00559463 -0.2727057 ]]
    """

    P1 = np.array(P1)
    P2 = np.array(P2)
    u1 = np.array(u1)
    u2 = np.array(u2)
    X = Pu2X(P1, P2, u1, u2)
    # print("X:")
    # print(X)
